## 编译和链接
- 预处理: 预处理器(preprocessor)执行以`#`开头的指令(directive)，例如`#include`指令, `#define`指令(宏定义, macro definition)等
- 编译: 将程序编译为机器指令(即目标代码, object code)
- 链接: 链接器(linker)将目标代码与附加代码整合

## 指针
- 现代计算机使用字节分割内存，每个字节都有唯一的地址，可以存储8位的信息.可执行程序由代码(原始C程序中与语句对应的机器指令)和数据(原始程序中的变量)构成,变量占有1到多个内存字节，将第一个字节的地址称为变量的地址。由于变量地址的取值范围可能不同于整数范围，因此无法用整型存储变量地址, 只能使用指针变量(pointer variable)。用指针变量p存储变量i的地址时，我们称p指向i,当然p也可以指向不用做变量的内存区域。`int i, a[10], *p;`
- 取地址运算符(`&`): `int i, *p = &i;`
- 间接寻址运算符(`*`): 只要指针`p`指向变量`i`,`*p`就是`i`的别名。若指针变量p未初始化，`*p`是未定义的，给`*p`赋值后p可能指向内存中的任何地方(可能属于程序或操作系统)。
- 指针赋值: `int i, *p, *q; p = &i; q = p;`是指针的赋值，p和q都指向了变量i。`*q = *p;`不是指针的赋值，是将p存储的内存地址复制给q。
- 当需要immutable时可以使用`const`, 例如`void fn(const int *p) {}`表示不能改变指针p指向的整数(不阻止改变p本身)
- 指针可能高效的原因是如果变量需要大量的存储空间，那么传递变量的值可能会浪费时间和空间。
- 指针的算术运算: 指针p加/减整数j产生指向特定元素的指针; 两个指针相减时结果为指针之间的距离(用于计算数组中元素个数)

## 数组
```c
#define length(array) (sizeof(array) / sizeof(array[0]))

int a[10] = {1, 2, 3};
printf("%d\n", *(&a[0] + 1) == 2);
*a += -1;
printf("%d\n", a[0] == 0 && *(a + 1) == 2);

int sum = 0;
for (int *p = a; p < a + length(a); p++) sum += *p;
for (int *p = &a[0]; p < &a[length(a)]; p++) sum += *p;

// C语言将字符当做整数处理
int arr['a'] = {0} // length(a) == 97
```




























