## 运行时数据区域
- 程序计数器(Program Counter Register): 在虚拟机概念模型中，字节码解释器通过改变程序计数器的值来选取下一条需要执行的字节码指令。每条线程都需要有一个独立的程序计数器，由于其独立存储互不影响，程序计数器的内存区域被称为"线程私有"的内存
- Java虚拟机栈(Virtual Machine Stacks): 每个方法在执行的同时都会创建一个栈帧(stack frame)用于存储局部变量表(内存空间在编译期间完成分配)，操作数栈，动态链接，方法出口等信息。局部变量表中存放了编译期可知的基本数据类型，对象引用(reference类型)和returnAddress类型。对象引用不等同于对象本身， 可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄; returnAddress类型指向了一条字节码指令的地址。`long`和`double`类型的数据会占用2个局部变量空间(Slot), 其他数据类型只占用1个。当线程请求的栈深度大于虚拟机允许的深度时将抛出`StackOverflowError`异常, 当虚拟机动态扩展时无法申请到足够的内存时将会抛出`OutOfMemoryError`异常
- 本地方法栈(Native Method Stack): 虚拟机栈为虚拟机执行Java方法(字节码)服务, 本地方法栈为虚拟机使用到的Native方法服务
- Java堆: Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，存在的唯一目的便是存放对象实例.由于Java堆是垃圾收集器管理的主要区域，因此有时也被称为GC堆。如果在堆中没有足够的内存完成实例分配，且堆无法再拓展时将抛出`OutOfMemoryError`异常
- 方法区(Method Area): 同Java堆一样也是各线程共享的内存区域, 用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等。Class文件中除了有类的版本，字段，方法，接口等描述信息外，还有编译期生成的各种字面量和符号引用，这部分内容会在类加载后被放入方法区的运行时常量池(Runtime Constant Pool)中存放

## Hotspot虚拟机对象
- 虚拟机遇到一条`new`指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载，解析和初始化过，若没有则执行类加载。之后虚拟机将为新生对象分配内存, 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值。接下来，虚拟机需要对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈希吗，对象的GC分代年龄等信息，最后执行<init>方法
- 若Java堆中的内存是规整的(已使用的内存与空闲内存之间放着一个指针作为分界点的指示器)，分配内存就是将指针向空闲空间方向挪动一段与对象大小相等的距离，这种内存分配方式被称为指针碰撞(bump the pointer)
- 若Java堆中的已使用的内存和空闲内存相互交错，虚拟机必须维护一个列表, 记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种内存分配方式被作为空闲列表(free list)
- 在HotSpot虚拟机中，对象在内存中存储的布局可分为: 对象头，实例数据和对齐填充(padding)
- 对象头: 包括存储对象自身的运行时数据(哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID, 偏向时间戳)与类型指针(即对象指向它的类元数据的指针)
- 实例数据: 程序代码中定义的各种类型的字段内容，内容的存储顺序受到虚拟机分配策略参数(FieldsAllocationStyle)和字段在Java源码中定义顺序影响。虚拟机默认分配策略为longs/doubles, ints, shorts/chars, bytes/booleans, ordinary object pointers
- 对齐填充: 虚拟机要求对象的起始地址必须是8字节的整数倍，而对象头部分正好是8字节的1倍或2倍，当对象实例数据部分未对齐时需要通过对齐填充来补全
- 对象的访问定位: 包括句柄访问和直接指针
- 句柄访问: Java堆会划分出一块内存来作为句柄池，reference中存储的便是对象的句柄地址，而句柄中包含了对象实例数据与类型数据(方法区)各自的具体地址信息
- 直接指针: reference中存储的便是对象地址, Java堆对象的布局中放置了访问类型数据的相关信息
