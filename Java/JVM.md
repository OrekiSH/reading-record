## 运行时数据区域
- 程序计数器(Program Counter Register): 在虚拟机概念模型中，字节码解释器通过改变程序计数器的值来选取下一条需要执行的字节码指令。每条线程都需要有一个独立的程序计数器，由于其独立存储互不影响，程序计数器的内存区域被称为"线程私有"的内存
- Java虚拟机栈(Virtual Machine Stacks): 每个方法在执行的同时都会创建一个栈帧(stack frame)用于存储局部变量表(内存空间在编译期间完成分配)，操作数栈，动态链接，方法出口等信息。局部变量表中存放了编译期可知的基本数据类型，对象引用(reference类型)和returnAddress类型。对象引用不等同于对象本身， 可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄; returnAddress类型指向了一条字节码指令的地址。`long`和`double`类型的数据会占用2个局部变量空间(Slot), 其他数据类型只占用1个。当线程请求的栈深度大于虚拟机允许的深度时将抛出`StackOverflowError`异常, 当虚拟机动态扩展时无法申请到足够的内存时将会抛出`OutOfMemoryError`异常
- 本地方法栈(Native Method Stack): 虚拟机栈为虚拟机执行Java方法(字节码)服务, 本地方法栈为虚拟机使用到的Native方法服务
- Java堆: Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，存在的唯一目的便是存放对象实例.由于Java堆是垃圾收集器管理的主要区域，因此有时也被称为GC堆。如果在堆中没有足够的内存完成实例分配，且堆无法再拓展时将抛出`OutOfMemoryError`异常
- 方法区(Method Area): 同Java堆一样也是各线程共享的内存区域, 用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等。Class文件中除了有类的版本，字段，方法，接口等描述信息外，还有编译期生成的各种字面量和符号引用，这部分内容会在类加载后被放入方法区的运行时常量池(Runtime Constant Pool)中存放

## Hotspot虚拟机对象
- 虚拟机遇到一条`new`指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载，解析和初始化过，若没有则执行类加载。之后虚拟机将为新生对象分配内存, 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值。接下来，虚拟机需要对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈希吗，对象的GC分代年龄等信息，最后执行<init>方法
- 若Java堆中的内存是规整的(已使用的内存与空闲内存之间放着一个指针作为分界点的指示器)，分配内存就是将指针向空闲空间方向挪动一段与对象大小相等的距离，这种内存分配方式被称为指针碰撞(bump the pointer)
- 若Java堆中的已使用的内存和空闲内存相互交错，虚拟机必须维护一个列表, 记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种内存分配方式被作为空闲列表(free list)
- 在HotSpot虚拟机中，对象在内存中存储的布局可分为: 对象头，实例数据和对齐填充(padding)
- 对象头: 包括存储对象自身的运行时数据(哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID, 偏向时间戳)与类型指针(即对象指向它的类元数据的指针)
- 实例数据: 程序代码中定义的各种类型的字段内容，内容的存储顺序受到虚拟机分配策略参数(FieldsAllocationStyle)和字段在Java源码中定义顺序影响。虚拟机默认分配策略为longs/doubles, ints, shorts/chars, bytes/booleans, ordinary object pointers
- 对齐填充: 虚拟机要求对象的起始地址必须是8字节的整数倍，而对象头部分正好是8字节的1倍或2倍，当对象实例数据部分未对齐时需要通过对齐填充来补全
- 对象的访问定位: 包括句柄访问和直接指针
- 句柄访问: Java堆会划分出一块内存来作为句柄池，reference中存储的便是对象的句柄地址，而句柄中包含了对象实例数据与类型数据(方法区)各自的具体地址信息
- 直接指针: reference中存储的便是对象地址, Java堆对象的布局中放置了访问类型数据的相关信息

## GC算法
- 对象存活判定算法: 引用计数(reference counting)和可达性分析(reachability analysis)
- 引用计数: 给对象添加一个引用计数器，有地方引用时加1，引用失效时减1，计数器为0时回收对象
- 可达性分析: 从GC Roots向下搜索，搜索路径称为引用链(reference chain)，当一个对象到GC Roots没有任何引用链相连时将被第一次标记。如果该对象覆盖了`finalize`方法或`finalize`没有被虚拟机调用过，该对象会被放置于F-Queue中，并由一个虚拟机自动建立的低优先级的Finalizer线程去执行`finalize`方法, 若`finalize`执行完该对象仍然没有与引用链上的任意对象建立关联则回收该对象
- GC Roots: 可作为GC Roots的对象有虚拟机栈中引用的对象，方法区中类静态属性/常量引用的对象，本地方法栈中JNI引用的对象
- 引用: JDK1.2后，Java将引用分为了强引用(例如`Object obj = new Object()`)，软引用(SoftReference)，弱引用(WeakReference)和虚引用(PhantomReference)
- 垃圾搜集算法: 标记-清除(mark-sweep), 复制， 标记-整理(mark-compact), 分代收集(generational collection)
- 标记-清除: 首先标记所有需要回收的对象，标记完成后统一回收被标记的对象。标记和清除的效率都不高，标记清除后会产生大量不连续的内存碎片, 空间碎片过多可能会导致后续的内存分配无法找到足够的连续内存而提前触发GC
- 复制: 将可用内存划分为两块，每次只使用其中的一块，当一块的内存用完了，便将依然存活的对象复制到另一块内存中并清理已使用过的内存空间
- 标记-整理: 标记完成后让所有存活的对象向一端移动，然后清理端边界以外的内存
- 分代收集: 根据对象存活周期将内存分为几块， 新生代使用复制算法，老生代使用标记-清除或者标记-整理算法
- HotSpot算法实现: 枚举根结点时必须停顿所有Java执行线程(Stop The World), 由于主流Java虚拟机使用的都是准确式GC，当程序执行停顿下来后并不需要检查所有执行上下文和全局的引用位置。在类加载完成时HotSpot会将对象内偏移量类型计算出来，在JIT编译过程中也会在特点的位置(安全点)记录下栈和寄存器中哪些位置是引用，并生成OopMap进行存储。虚拟机并不会为每条导致引用关系变化的指令生成对应的OopMap, 只有在安全点(safepoint)和安全区域(safe region)才会将程序执行停顿, 序列复用的指令(方法调用，循环跳转，异常跳转)才会产生安全点, 当GC需要中断线程时在安全点处设置一个标志，各个线程主动轮询这个标志，发现中断标志为真时自己中断挂起；当线程执行到安全区域中代码时将自己标识为进入安全区域，当JVM发起GC时不管标识为安全区域的线程

## 垃圾收集器
- Serial: 单线程收集器，进行GC时必须暂停所有用户线程, 新生代名为DefNew(Default New Generation)
- ParNew: 多线程收集器, 多条GC线程并行(parallel)工作, 用户线程仍处于等待状态
- Parallel Scavenge: 多线程收集器, 着重于达到一个可控的吞吐量(throughput), 即CPU用于运行用户代码的时间与CPU总消耗时间的比值
- Serial Old: Serial的老年代版本, 使用标记-整理算法
- Parallel Old: Parallel Scavenge的老年代版本, 使用标记-整理算法
- CMS(Concurrent Mark Sweep): 初始标记(标记GC Roots能够直接关联的对象) -> 并发标记 -> 重新标记(修正并发标记期间的标记变动)-> 并发清除。对CPU资源非常敏感, 无法处理浮动垃圾(并发清除期间产生的垃圾)，标记-清除算法容易产生大量空间碎片
- G1(Garbage-First): 使用复制算法与标记-整理算法。将Java堆划分为大小相等的独立区域，新生代和老生代不再物理隔离。通过跟踪各个独立区域中垃圾堆积的价值(回收可获得空间/回收时间)大小，优先回收价值最大的区域, 建立了可预测的停顿时间模型
- `[Times: user=0.01 sys=0.00 real=0.02 secs]`, 分别代表用户态消耗的CPU时间，内核态消耗的CPU时间，操作从开始到结束的墙钟时间(Wall Clock Time), Wall Clock Time包括非运算的等待耗时，如I/O,线程阻塞等

## 内存分配和回收策略
- 对象优先在Eden分配: 大多数情况下，对象在新生代Eden区分配，当Eden区没有足够空间分配时虚拟机将发起一次Minor GC(新生代GC)
- 大对象直接进入老年代: 大对象指的是需要大量连续内存空间的Java对象, 如`byte[] allocation = new byte[4 * 1024 * 1024]`
- 长期存活的对象将进入老年代: 虚拟机给每个对象定义了一个对象年龄计数器, 对象在Eden被分配且经过第一次Minor GC后依然存活，且能被Survivor容纳的话将被移动到Survivor中，且对象年龄计数器的值被设为1, 之后每经过一次Minor GC计数器加1，当计数器的值达到15(-XX:MaxTenuringThreshold)时该对象将被移动到老年代
- 动态对象年龄判定: 当Survivor空间中相同年龄的对象大小总和超过Survivor的一半是，年龄大于等于该年龄的对象直接进入老年代
- 空间分配担保: Minor GC之前，JVM会先检查老年代最大可用连续内存空间是否大于新生代所有对象之和，条件成立则认为Minor GC是安全的(复制算法)；若条件不成立JVM将会查看`HandlePromotionFailure`的设置值, 如果允许担保失败，将检查老年代最大可用连续内存空间是否大于每次晋升到老年代对象的评价大小，若条件成立则进行Minor GC, 否则进行Full GC
