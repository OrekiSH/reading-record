## 运行时数据区域
- 程序计数器(Program Counter Register): 在虚拟机概念模型中，字节码解释器通过改变程序计数器的值来选取下一条需要执行的字节码指令。每条线程都需要有一个独立的程序计数器，由于其独立存储互不影响，程序计数器的内存区域被称为"线程私有"的内存
- Java虚拟机栈(Virtual Machine Stacks): 每个方法在执行的同时都会创建一个栈帧(stack frame)用于存储局部变量表(内存空间在编译期间完成分配)，操作数栈，动态链接，方法出口等信息。局部变量表中存放了编译期可知的基本数据类型，对象引用(reference类型)和returnAddress类型。对象引用不等同于对象本身， 可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄; returnAddress类型指向了一条字节码指令的地址。`long`和`double`类型的数据会占用2个局部变量空间(Slot), 其他数据类型只占用1个。当线程请求的栈深度大于虚拟机允许的深度时将抛出`StackOverflowError`异常, 当虚拟机动态扩展时无法申请到足够的内存时将会抛出`OutOfMemoryError`异常
- 本地方法栈(Native Method Stack): 虚拟机栈为虚拟机执行Java方法(字节码)服务, 本地方法栈为虚拟机使用到的Native方法服务
- Java堆: Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，存在的唯一目的便是存放对象实例.由于Java堆是垃圾收集器管理的主要区域，因此有时也被称为GC堆。如果在堆中没有足够的内存完成实例分配，且堆无法再拓展时将抛出`OutOfMemoryError`异常
- 方法区(Method Area): 同Java堆一样也是各线程共享的内存区域, 用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等。Class文件中除了有类的版本，字段，方法，接口等描述信息外，还有编译期生成的各种字面量和符号引用，这部分内容会在类加载后被放入方法区的运行时常量池(Runtime Constant Pool)中存放
